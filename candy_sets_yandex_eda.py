#!/usr/bin/env python
# coding: utf-8

# #### У вас есть список конфет разных видов, вам нужно собрать одинаковые наборы для своих друзей. Какому максимальному числу друзей вы сможете собрать наборы так, чтобы раздарить все конфеты?

# Основная цель - раздать ВСЕ конфеты.
# 
# Сначала считаем, сколько конфет каждого вида встречается в списке. Смотрим, на сколько одинаковых наборов можно разделить все эти конфеты. Число таких наборов равно количеству общих делителей числа конфет каждого вида в списке.
# 
# Например, для списка  [A A A A A A A A A A A A B B B B B B C C C C C C] : конфет вида A - 12 штук, вида B - 6 штук, вида C - 6 штук. Его можно разбить на 1 набор, состоящий из всех конфет, на 2 набора [A A A A A A B B B C C C], на 3 набора [A A A A A A B B B C C C], и на 6 наборов [A A B C]
# 
# Так как конфеты надо раздать максимально возможному количеству друзей, то берем наибольшее количество наборов ( т.е. наибольший общий делитель)

# In[109]:


import numpy as np

def sets_for_friends(candy_set):

    # смотрим на количество конфет каждого вида:
    candy_types = [[i for i in np.unique(candy_input)], [candy_input.count(i) for i in np.unique(candy_input)]]
    
    #находим наибольший общий делитель для количеств конфет каждого вида
    
    #сначала выпишем списки всех делителей:
    set1 = []
    for a in candy_types[1] :
        set2=set()
        for i in range(1, a+1) :
            if a % i == 0 :
                set2.add(i)
        set1.append(set2)
    
    #найдем их пересечение (множество общих делителей):
    intersec = set1[0]
    for i in range(1, np.size(candy_types[0])):
        intersec = intersec.intersection(set1[i])
    
    #берем наибольший элемент из перечечения
    return max(intersec)


# In[106]:


candy_input = input().split(" ")

